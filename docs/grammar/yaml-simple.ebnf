// YAML Simplified Grammar (Phase 1 Implementation)
// This is a subset of YAML 1.2 for initial implementation.
// Start with this, then progressively add features from yaml-1.2.ebnf
//
// What's Included (MVP):
// - Block mappings (key: value with indentation)
// - Block sequences (- item with indentation)
// - Plain scalars (strings, numbers, booleans, null)
// - Quoted scalars (single and double quotes)
// - Comments (#)
//
// What's Excluded (Add Later):
// - Anchors and aliases (&name, *name)
// - Multi-line strings (| and >)
// - Flow style ({}, [])
// - Tags (!type)
// - Multiple documents (---)
// - Complex keys (? marker)
// - Merge keys (<<)
//
// Implementation Strategy:
// Phase 1: This simplified grammar
// Phase 2: Add anchors/aliases
// Phase 3: Add multi-line strings
// Phase 4: Add flow style
// Phase 5: Full YAML 1.2 spec

// =============================================================================
// Top-Level Document (Simplified)
// =============================================================================

// Document: single YAML document (mapping, sequence, or scalar)
// Parser function: Parse() -> ast.SchemaNode
Document = Node ;

// Node: any YAML value
// Parser function: parseNode() -> ast.SchemaNode
Node = BlockMapping | BlockSequence | Scalar ;

// =============================================================================
// Block Mapping (Key-Value Pairs)
// =============================================================================

// Block mapping: indentation-based key-value pairs
// Parser function: parseBlockMapping() -> *ast.ObjectNode
// Example:
//   name: Alice
//   age: 30
//   address:
//     city: NYC
// Returns: ast.NewObjectNode(properties, position)
// Properties: map[string]ast.SchemaNode{"name": LiteralNode("Alice"), "age": LiteralNode(30), ...}
BlockMapping = MappingEntry { MappingEntry } ;

// Mapping entry: key: value
// Parser function: parseMappingEntry() -> (key string, value ast.SchemaNode)
// Must maintain consistent indentation
MappingEntry = [ Indent ] Key Colon [ Space ] Value [ Comment ] Newline ;

// Key: plain or quoted string
Key = PlainString | QuotedString ;

// Colon separator
Colon = ":" ;

// =============================================================================
// Block Sequence (List Items)
// =============================================================================

// Block sequence: list with dash markers
// Parser function: parseBlockSequence() -> *ast.ObjectNode
// Example:
//   - apple
//   - banana
//   - cherry
// Returns: ast.NewObjectNode with numeric keys "0", "1", "2"
// Properties: map[string]ast.SchemaNode{"0": LiteralNode("apple"), "1": LiteralNode("banana"), ...}
BlockSequence = SequenceEntry { SequenceEntry } ;

// Sequence entry: - value
// Parser function: parseSequenceEntry() -> ast.SchemaNode
// Must maintain consistent indentation
SequenceEntry = [ Indent ] Dash [ Space ] Value [ Comment ] Newline ;

// Dash marker
Dash = "-" ;

// =============================================================================
// Scalars (Values)
// =============================================================================

// Value: any YAML value
// Parser function: parseValue() -> ast.SchemaNode
Value = BlockMapping | BlockSequence | Scalar ;

// Scalar: primitive value
// Parser function: parseScalar() -> *ast.LiteralNode
Scalar = QuotedString | PlainScalar ;

// Quoted string: single or double quotes
// Parser function: parseQuotedString() -> *ast.LiteralNode
// Example: "hello world"
// Example: 'single quotes'
// Returns: ast.NewLiteralNode(string_value, position)
QuotedString = DoubleQuotedString | SingleQuotedString ;

// Double-quoted string
// Parser function: parseDoubleQuotedString() -> *ast.LiteralNode
// Supports escape sequences: \", \\, \n, \t, \r, \uXXXX
// Example: "Line 1\nLine 2"
// Returns: ast.NewLiteralNode("Line 1\nLine 2", position)
DoubleQuotedString = '"' { DoubleQuotedChar } '"' ;
DoubleQuotedChar = UnescapedChar | EscapeSequence ;

// Unescaped character
UnescapedChar = [^"\\\x00-\x1F] ;

// Escape sequences
EscapeSequence = "\\" ( '"' | "\\" | "/" | "n" | "t" | "r" | UnicodeEscape ) ;
UnicodeEscape = "u" HexDigit HexDigit HexDigit HexDigit ;
HexDigit = [0-9a-fA-F] ;

// Single-quoted string
// Parser function: parseSingleQuotedString() -> *ast.LiteralNode
// No escape sequences except '' (escaped single quote)
// Example: 'it''s working'
// Returns: ast.NewLiteralNode("it's working", position)
SingleQuotedString = "'" { SingleQuotedChar } "'" ;
SingleQuotedChar = [^'] | "''" ;

// Plain scalar: unquoted value (string, number, boolean, null)
// Parser function: parsePlainScalar() -> *ast.LiteralNode
// Auto-detects type based on content
// Examples:
//   hello      → string: "hello"
//   123        → int64: 123
//   3.14       → float64: 3.14
//   true       → bool: true
//   null       → nil
// Returns: ast.NewLiteralNode(value, position)
PlainScalar = Number | Boolean | Null | PlainString ;

// Plain string: unquoted text
// Cannot start with: - ? : , [ ] { } # & * ! | > ' " % @ `
// Cannot contain: ": " or " #" (colon-space or space-hash)
// Stops at: newline, colon-space, space-hash
PlainString = PlainStartChar { PlainSafeChar } ;
PlainStartChar = [^-?:,\[\]{}#&*!|>'"%@`\n\t ] ;
PlainSafeChar = [^\n:#] ;

// Number: integer or float
// Parser function: parseNumber() -> *ast.LiteralNode
// Examples:
//   42    → int64(42)
//   -17   → int64(-17)
//   3.14  → float64(3.14)
//   1e10  → float64(1e10)
// Returns: ast.NewLiteralNode(int64 or float64, position)
Number = [ "-" ] Integer [ Fraction ] [ Exponent ] ;
Integer = "0" | ( [1-9] { Digit } ) ;
Digit = [0-9] ;
Fraction = "." Digit+ ;
Exponent = ( "e" | "E" ) [ "+" | "-" ] Digit+ ;

// Boolean: true or false
// Parser function: parseBoolean() -> *ast.LiteralNode
// YAML 1.2 Core Schema: only "true" and "false"
// We also support: yes, no (common YAML usage)
// Returns: ast.NewLiteralNode(bool, position)
Boolean = "true" | "false" | "yes" | "no" ;

// Null: null or ~
// Parser function: parseNull() -> *ast.LiteralNode
// Returns: ast.NewLiteralNode(nil, position)
Null = "null" | "~" ;

// =============================================================================
// Indentation and Whitespace
// =============================================================================

// Indentation: spaces only (tabs not allowed)
// Parser tracks indentation levels on a stack
// Emit INDENT when level increases
// Emit DEDENT when level decreases
Indent = Space+ ;

// Space character
Space = " " ;

// Newline
Newline = "\n" | "\r\n" ;

// Comment: # followed by text until newline
// Parser function: skipComment() (ignored during parsing)
// Example: # this is a comment
Comment = "#" [^\n]* ;

// =============================================================================
// Implementation Notes
// =============================================================================

// Indentation Tracking:
// 1. Maintain stack of indentation levels: [0]
// 2. On newline, measure leading spaces
// 3. If spaces > stack.top(): push(spaces), emit INDENT
// 4. If spaces < stack.top(): pop until match, emit DEDENT for each pop
// 5. If spaces == stack.top(): continue at same level

// Type Detection for Plain Scalars:
// 1. Try to parse as number:
//    - Match integer pattern: return int64
//    - Match float pattern: return float64
// 2. Check exact matches:
//    - "true", "yes" → return bool(true)
//    - "false", "no" → return bool(false)
//    - "null", "~" → return nil
// 3. Otherwise: return string

// Example Parsing:
//
// Input:
//   name: Alice
//   age: 30
//   tags:
//     - admin
//     - user
//
// AST Output:
//   *ast.ObjectNode{
//     properties: {
//       "name": *ast.LiteralNode{value: "Alice"},
//       "age":  *ast.LiteralNode{value: int64(30)},
//       "tags": *ast.ObjectNode{
//         properties: {
//           "0": *ast.LiteralNode{value: "admin"},
//           "1": *ast.LiteralNode{value: "user"},
//         },
//       },
//     },
//   }

// Error Handling:
// - Track line and column positions
// - Provide context in error messages
// - Example: "unexpected indentation at line 5, column 3 (expected 2 spaces)"

// Next Steps (After MVP):
// 1. Add anchors (&name) and aliases (*name)
// 2. Add multi-line strings (| and >)
// 3. Add flow style ({key: value} and [item1, item2])
// 4. Add tags (!type)
// 5. Add multiple documents (---)
